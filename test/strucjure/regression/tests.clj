(ns strucjure.regression.tests
  (:refer-clojure :exclude [with-meta or and * num])
  (:require [clojure.stacktrace :refer [e]]
            [plumbing.core :refer [map-vals fnk]]
            [strucjure.pattern :refer :all]
            [strucjure.graph :refer :all]
            [strucjure.sugar :refer :all]))

(pattern->view (->Bind 'a 1))
(pattern->view (->Output (->Bind 'a 1) (fnk [a] (+ a 1))))
(pattern->view (list 1 2))
((eval (pattern->view (list 1 2))) (list 1 2))
((eval (pattern->view (list 1 2))) (list 1))
((eval (pattern->view (list 1 2))) (list 1 2 3))
((eval (pattern->view (list 1 2))) (list 1 3))
((eval (pattern->view (list 1 2))) [1 2])
((eval (pattern->view (list 1 2))) 1)
(let [a (eval (pattern->view 1))] (pattern->view (list (->View a) 2)))
(let [a (eval (pattern->view 1))] ((eval (pattern->view (list (->View a) 2))) (list 1 2 3)))
((eval (pattern->view (list))) (list))
((eval (pattern->view (list))) (list 1 2))
((eval (pattern->view (list))) nil)
((eval (pattern->view (->ZeroOrMore 1))) (list))
((eval (pattern->view (->ZeroOrMore 1))) (list 2))
((eval (pattern->view (->ZeroOrMore 1))) (list 1 1))
((eval (pattern->view (->ZeroOrMore 1))) (list 1 1 2))
((eval (pattern->view (->ZeroOrMore (->Or [1 2])))) (list 1 2 1 2 3))
((eval (pattern->view (->ZeroOrMore (->Rest (list 1))))) (list 1 1 1))
(pattern->view (->ZeroOrMore 1))
(pattern->view (->Output (->ZeroOrMore 1) (fnk [] 'ones)))
(pattern->view (->Output (->Bind 'a (->ZeroOrMore 1)) (fnk [a] a)))
(let [[out rem] ((eval (pattern->view (->WithMeta (->Any) {:foo true}))) ^:foo [])]
  (meta out))
((eval (pattern->view [1 2])) [1])
((eval (pattern->view [1 2])) [1 2])
((eval (pattern->view [1 2])) [1 2 3])
((eval (pattern->view [1 2])) [1 3])
((eval (pattern->view (list (->Rest (->Bind 'elems (->ZeroOrMore (->Rest (->Any)))))))) (list 1 2 3))
((eval (pattern->view (->Seqable [(->Rest (->ZeroOrMore [(->Any) (->Any)]))]))) '{:foo 1 :bar (& * 3)})
((eval (pattern->view (->And [{} (->Bind 'elems (->Seqable [(->Rest (->ZeroOrMore [(->Any) (->Any)]))]))]))) '{:foo 1 :bar (& * 3)})
((eval (pattern->view [(->Any) (->Any)])) (first (seq '{:foo 1 :bar (& * 3)})))
(eval (pattern->view (->Output (list (->WithMeta (->Bind 'prefix (->Or ['*])) (->Any)) (->Rest (->View 'inc))) (fnk [prefix] prefix))))
((eval (pattern->view (->Output (->Bind 'a (list 1 (->Bind 'a 2))) (fnk [a] a)))) (list 1 2))
(def eg-num
  {'num (->Or [(->View 'zero) (->View 'succ)])
   'zero 'zero
   'succ (list 'succ (->Bind 'x (->View 'num)))})
(def eg-num-out
  (output-in eg-num
             'zero (fnk [] 0)
             'succ (fnk [x] (inc x))))
(def num (eval (graph->view 'num (with-print-trace eg-num-out))))
(num 'zero)
(num 'foo)
(num (list 'succ 'zero))
(num (list 'succ (list 'succ 'zero)))
(num (list 'succ (list 'succ 'succ)))
(macroexpand-1 '(pattern [1 2 & * 3]))
(pattern [1 2 & * 3])
(pattern [1 2 ^x & * 3])
(pattern [1 2 & ^x * 3])
(pattern {:foo 1 :bar (& * 3)})
(pattern [1 2 ~(or 3 4)])
(pattern [1 2 ^x ~(->View 'foo)])
(view [1 2 & * 3] [1 2])
(view [1 2 & * 3] [1 2 3 3 3])
(view [1 2 & * 3] [1 2 3 3 3 4])
(view ~(output [1 2 ^rest & * 3] (fnk [rest] rest)) [1 2 3 3 3])
(pattern ~(or [(->Bind 'succ (->View 'succ)) (->Bind 'zero (->View 'zero))]))
(macroexpand-1 '(pattern (1 2 3)))
(macroexpand-1 '(pattern (succ)))
(def num-graph
  (graph
   num ~(or ~succ ~zero)
   succ (succ ~num)
   zero zero))
(def num (eval (graph->view 'num num-graph)))
(num 'zero)
(num '(succ (succ zero)))
(num '(1 (succ zero)))
(num '(succ succ))
