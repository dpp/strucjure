;; (in-ns 'strucjure.regression.sandbox)
(pattern->view (->Bind 'a 1))
(pattern->view (->Output (->Bind 'a 1) (fnk [a] (+ a 1))))
(pattern->view (list 1 2))
((eval (pattern->view (list 1 2))) (list 1 2))
((eval (pattern->view (list 1 2))) (list 1))
((eval (pattern->view (list 1 2))) (list 1 2 3))
((eval (pattern->view (list 1 2))) (list 1 3))
((eval (pattern->view (list 1 2))) [1 2])
((eval (pattern->view (list 1 2))) 1)
(let [a (eval (pattern->view 1))] (pattern->view (list (->View a) 2)))
(let [a (eval (pattern->view 1))] ((eval (pattern->view (list (->View a) 2))) (list 1 2 3)))
((eval (pattern->view (list))) (list))
((eval (pattern->view (list))) (list 1 2))
((eval (pattern->view (list))) nil)
((eval (pattern->view (->ZeroOrMore 1))) (list))
((eval (pattern->view (->ZeroOrMore 1))) (list 2))
((eval (pattern->view (->ZeroOrMore 1))) (list 1 1))
((eval (pattern->view (->ZeroOrMore 1))) (list 1 1 2))
((eval (pattern->view (->ZeroOrMore (->Or [1 2])))) (list 1 2 1 2 3))
((eval (pattern->view (->ZeroOrMore (->Rest (list 1))))) (list 1 1 1))
(pattern->view (->ZeroOrMore 1))
(pattern->view (->Output (->ZeroOrMore 1) (fnk [] 'ones)))
(pattern->view (->Output (->Bind 'a (->ZeroOrMore 1)) (fnk [a] a)))
(let [[out rem] ((eval (pattern->view (->WithMeta (->Any) {:foo true}))) ^:foo [])]
  (meta out))
((eval (pattern->view [1 2])) [1])
((eval (pattern->view [1 2])) [1 2])
((eval (pattern->view [1 2])) [1 2 3])
((eval (pattern->view [1 2])) [1 3])
((eval (pattern->view (list (->Rest (->Bind 'elems (->ZeroOrMore (->Rest (->Any)))))))) (list 1 2 3))
((eval (pattern->view (->Seqable [(->Rest (->ZeroOrMore [(->Any) (->Any)]))]))) '{:foo 1 :bar (& * 3)})
((eval (pattern->view (->And [{} (->Bind 'elems (->Seqable [(->Rest (->ZeroOrMore [(->Any) (->Any)]))]))]))) '{:foo 1 :bar (& * 3)})
((eval (pattern->view [(->Any) (->Any)])) (first (seq '{:foo 1 :bar (& * 3)})))
(eval (pattern->view (->Output (list (->WithMeta (->Bind 'prefix (->Or ['*])) (->Any)) (->Rest (->View 'inc))) (fnk [prefix] prefix))))
((eval (pattern->view (->Output (->Bind 'a (list 1 (->Bind 'a 2))) (fnk [a] a)))) (list 1 2))
(def eg-num
  {'num (->Or [(->View 'zero) (->View 'succ)])
   'zero 'zero
   'succ (list 'succ (->Bind 'x (->View 'num)))})
(def eg-num-out
  (output-in eg-num
             'zero (fnk [] 0)
             'succ (fnk [x] (inc x))))
(def num (eval (graph->view 'num eg-num-out)))
(num 'zero)
(num 'foo)
(num (list 'succ 'zero))
(num (list 'succ (list 'succ 'zero)))
(num (list 'succ (list 'succ 'succ)))
(macroexpand-1 '(pattern [1 2 & * 3]))
(pattern [1 2 & * 3])
(pattern [1 2 ^x & * 3])
(pattern [1 2 & ^x * 3])
(pattern {:foo 1 :bar (& * 3)})
(pattern [1 2 ~(or 3 4)])
(pattern [1 2 ^x ~(->View 'foo)])
((view [1 2 & * 3]) [1 2])
((view [1 2 & * 3]) [1 2 3 3 3])
((view [1 2 & * 3]) [1 2 3 3 3 4])
(pattern [1 2 ^x _])
(macroexpand '(pattern [1 2 ^x & _]))
(macroexpand '(pattern [1 2 & ^x _]))
((view ~(output [1 2 ^x & _] (fnk [x] x))) [1 2 3 4])
((view ~(output [1 2 & ^x _] (fnk [x] x))) [1 2 3 4])
(pattern ~(output [1 2 ^rest & * 3] (fnk [rest] rest)))
(pattern->view (pattern ~(output [1 2 ^rest & * 3] (fnk [rest] rest))))
((view ~(output [1 2 ^rest & * 3] (fnk [rest] rest))) [1 2 3 3 3])
(pattern ~(or [(->Bind 'succ (->View 'succ)) (->Bind 'zero (->View 'zero))]))
(macroexpand-1 '(pattern (1 2 3)))
(macroexpand-1 '(pattern (succ)))
(def num-graph
  (graph
   num ~(or ~succ ~zero)
   succ (succ ^x ~num)
   zero zero))
(def num-out
  (output-in num-graph
             'zero (fnk [] 0)
             'succ (fnk [x] (inc x))))
(macroexpand-1 '(graph foo ~foo))
(def num (eval (graph->view 'num num-out)))
(num 'zero)
(num '(succ (succ zero)))
(num '(1 (succ zero)))
(num '(succ succ))
(macroexpand-1 '(trace-pattern [1 2 3] [1 2 3]))
(macroexpand-1 '(trace [1 2 3]))
((trace [1 2 3]) [1 2 3])
(pattern [1 2 3])
(pattern->view (strucjure.debug/pattern-with-print-trace (pattern [1 2 3])))
((trace ~(or {:1 2 :3 [4 5]} {:1 2})) {:1 2 :3 [3 5]})
