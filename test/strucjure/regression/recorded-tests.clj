((eval (pattern->view (->Guard 1 (fnk [] true)) true true)) 1)
((eval (pattern->view (list 1 2 3) true true)) (list 1 2 3))
((eval (pattern->view (list 1 2 3) true true)) (list 1 2 3 4))
((eval (pattern->view (list 1 2 3) true true)) (list 1 2))
(pattern->view (->Name (quote a) 1) true true)
(bound (->Name (quote a) 1))
(used (->Output (->Name (quote a) 1) (fnk [a] (+ a 1))))
((eval (pattern->view (->Output (->Name (quote a) 1) (fnk [a] (+ a 1))) true true)) 1)
((eval (pattern->view (->Output (->Name (quote a) 1) (fnk [a] (+ a 1))) true true)) 2)
(pattern->view (list 1 2) true true)
((eval (pattern->view (list 1 2) true true)) (list 1 2))
((eval (pattern->view (list 1 2) true true)) (list 1))
((eval (pattern->view (list 1 2) true true)) (list 1 2 3))
((eval (pattern->view (list 1 2) true true)) (list 1 3))
((eval (pattern->view (list 1 2) true true)) [1 2])
((eval (pattern->view (list) true true)) (list))
((eval (pattern->view (list) true true)) (list 1 2))
((eval (pattern->view (list) true true)) nil)
((eval (pattern->view (->ZeroOrMore 1) true true)) (list))
((eval (pattern->view (->ZeroOrMore 1) true true)) (list 2))
((eval (pattern->view (->ZeroOrMore 1) true true)) (list 1 1))
((eval (pattern->view (->ZeroOrMore 1) true true)) (list 1 1 2))
((eval (pattern->view (->ZeroOrMore (->Or [1 2])) true true)) (list 1 2 1 2 3))
((eval (pattern->view (->ZeroOrMore (->Rest (list 1))) true true)) (list 1 1 1))
(pattern->view (->ZeroOrMore 1) true true)
(pattern->view (->Output (->ZeroOrMore 1) (fnk [] (quote ones))) true true)
(pattern->view (->Output (->Name (quote a) (->ZeroOrMore 1)) (fnk [a] a)) true true)
(let [[out rem] ((eval (pattern->view (->WithMeta (->Any) {:foo true}) true true)) ^{:foo true} [])] (meta out))
((eval (pattern->view [1 2] true true)) [1])
((eval (pattern->view [1 2] true true)) [1 2])
((eval (pattern->view [1 2] true true)) [1 2 3])
((eval (pattern->view [1 2] true true)) [1 3])
((eval (pattern->view (list (->Rest (->Name (quote elems) (->ZeroOrMore (->Any))))) true true)) (list 1 2 3))
((eval (pattern->view (->Seqable [(->Rest (->ZeroOrMore [(->Any) (->Any)]))]) true true)) (quote {:foo 1, :bar (& * 3)}))
((eval (pattern->view (->And [{} (->Name (quote elems) (->Seqable [(->Rest (->ZeroOrMore [(->Any) (->Any)]))]))]) true true)) (quote {:foo 1, :bar (& * 3)}))
((eval (pattern->view [(->Any) (->Any)] true true)) (first (seq (quote {:foo 1, :bar (& * 3)}))))
((eval (pattern->view (->Output (->Name (quote a) (list 1 (->Name (quote a) 2))) (fnk [a] [:a a])) true true)) (list 1 2))
(def eg-num {(quote num) (->Or [(->Node (quote zero)) (->Node (quote succ))]), (quote zero) (quote zero), (quote succ) (list (quote succ) (->Name (quote x) (->Node (quote num))))})
(def eg-num-out (output-in eg-num (quote zero) (fnk [] 0) (quote succ) (fnk [x] (inc x))))
(def num (eval (graph->view (quote num) eg-num-out)))
(num (quote zero))
(num (quote foo))
(num (list (quote succ) (quote zero)))
(num (list (quote succ) (list (quote succ) (quote zero))))
(num (list (quote succ) (list (quote succ) (quote succ))))
(named-node (->Node (quote zero)))
(postwalk (->Node (quote zero)) named-node)
(with-named-inner-nodes eg-num)
(pattern->view (->Is (fn* [p1__28180#] (symbol? p1__28180#))) true true)
(macroexpand-1 (quote (pattern [1 2 & * 3])))
(pattern [1 2 & * 3])
((eval (pattern->view (->ZeroOrMore 3) true true)) [])
((eval (pattern->view (pattern [& * 3]) true true)) [])
(pattern [1 2 ^x & * 3])
(pattern [1 2 & ^x * 3])
(pattern {:foo 1, :bar (& * 3)})
(pattern [1 2 (clojure.core/unquote (or 3 4))])
(pattern [1 2 ^x (clojure.core/unquote (->Node (quote foo)))])
((view [1 2 & * 3]) [1 2])
((view [1 2 & * 3]) [1 2 3 3 3])
((view [1 2 & * 3]) [1 2 3 3 3 4])
(pattern [1 2 ^x _])
(macroexpand (quote (pattern [1 2 ^x & _])))
(macroexpand (quote (pattern [1 2 & ^x _])))
((view (clojure.core/unquote (output [1 2 ^x & _] (fnk [x] x)))) [1 2 3 4])
((view (clojure.core/unquote (output [1 2 & ^x _] (fnk [x] x)))) [1 2 3 4])
(pattern (clojure.core/unquote (output [1 2 ^rest & * 3] (fnk [rest] rest))))
(pattern->view (pattern (clojure.core/unquote (output [1 2 ^rest & * 3] (fnk [rest] rest)))) true true)
((view (clojure.core/unquote (output [1 2 ^rest & * 3] (fnk [rest] rest)))) [1 2 3 3 3])
(pattern (clojure.core/unquote (or [(->Name (quote succ) (->View (quote succ))) (->Name (quote zero) (->View (quote zero)))])))
(macroexpand-1 (quote (pattern (1 2 3))))
(macroexpand-1 (quote (pattern (succ))))
(def num-graph (graph num (clojure.core/unquote (or (clojure.core/unquote succ) (clojure.core/unquote zero))) succ (succ ^x (clojure.core/unquote num)) zero zero))
(def num-out (output-in num-graph (quote zero) (fnk [] 0) (quote succ) (fnk [x] (inc x))))
(macroexpand-1 (quote (graph foo (clojure.core/unquote foo))))
(def num (eval (graph->view (quote num) num-out)))
(num (quote zero))
(num (quote (succ (succ zero))))
(num (quote (1 (succ zero))))
(num (quote (succ succ)))
(macroexpand-1 (quote (trace [1 2 3])))
((trace [1 2 3]) [1 2 3])
((trace (clojure.core/unquote (or {:1 2, :3 [4 5]} {:1 2}))) {:1 2, :3 [3 5]})
(macroexpand-1 (quote (view (clojure.core/unquote (->Graph (quote num) num-out)))))
(graph->view (quote num) num-out)
((view (clojure.core/unquote (->Graph (quote num) num-out))) (quote (succ (succ zero))))