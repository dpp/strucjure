(pattern->view (->Bind (quote a) 1))
(pattern->view (->Output (->Bind (quote a) 1) (fnk [a] (+ a 1))))
(pattern->view (list 1 2))
((eval (pattern->view (list 1 2))) (list 1 2))
((eval (pattern->view (list 1 2))) (list 1))
((eval (pattern->view (list 1 2))) (list 1 2 3))
((eval (pattern->view (list 1 2))) (list 1 3))
((eval (pattern->view (list 1 2))) [1 2])
((eval (pattern->view (list 1 2))) 1)
(let [a (eval (pattern->view 1))] (pattern->view (list (->View a) 2)))
(let [a (eval (pattern->view 1))] ((eval (pattern->view (list (->View a) 2))) (list 1 2 3)))
((eval (pattern->view (list))) (list))
((eval (pattern->view (list))) (list 1 2))
((eval (pattern->view (list))) nil)
((eval (pattern->view (->ZeroOrMore 1))) (list))
((eval (pattern->view (->ZeroOrMore 1))) (list 2))
((eval (pattern->view (->ZeroOrMore 1))) (list 1 1))
((eval (pattern->view (->ZeroOrMore 1))) (list 1 1 2))
((eval (pattern->view (->ZeroOrMore (->Or [1 2])))) (list 1 2 1 2 3))
((eval (pattern->view (->ZeroOrMore (->Rest (list 1))))) (list 1 1 1))
(pattern->view (->ZeroOrMore 1))
(pattern->view (->Output (->ZeroOrMore 1) (fnk [] (quote ones))))
(pattern->view (->Output (->Bind (quote a) (->ZeroOrMore 1)) (fnk [a] a)))
(let [[out rem] ((eval (pattern->view (->WithMeta (->Any) {:foo true}))) ^{:foo true} [])] (meta out))
((eval (pattern->view [1 2])) [1])
((eval (pattern->view [1 2])) [1 2])
((eval (pattern->view [1 2])) [1 2 3])
((eval (pattern->view [1 2])) [1 3])
((eval (pattern->view (list (->Rest (->Bind (quote elems) (->ZeroOrMore (->Rest (->Any)))))))) (list 1 2 3))
((eval (pattern->view (->Seqable [(->Rest (->ZeroOrMore [(->Any) (->Any)]))]))) (quote {:foo 1, :bar (& * 3)}))
((eval (pattern->view (->And [{} (->Bind (quote elems) (->Seqable [(->Rest (->ZeroOrMore [(->Any) (->Any)]))]))]))) (quote {:foo 1, :bar (& * 3)}))
((eval (pattern->view [(->Any) (->Any)])) (first (seq (quote {:foo 1, :bar (& * 3)}))))
(eval (pattern->view (->Output (list (->WithMeta (->Bind (quote prefix) (->Or [(quote *)])) (->Any)) (->Rest (->View (quote inc)))) (fnk [prefix] prefix))))
((eval (pattern->view (->Output (->Bind (quote a) (list 1 (->Bind (quote a) 2))) (fnk [a] a)))) (list 1 2))
(def eg-num {(quote num) (->Or [(->View (quote zero)) (->View (quote succ))]), (quote zero) (quote zero), (quote succ) (list (quote succ) (->Bind (quote x) (->View (quote num))))})
(def eg-num-out (output-in eg-num (quote zero) (fnk [] 0) (quote succ) (fnk [x] (inc x))))
(def num (eval (graph->view (quote num) eg-num-out)))
(num (quote zero))
(num (quote foo))
(num (list (quote succ) (quote zero)))
(num (list (quote succ) (list (quote succ) (quote zero))))
(num (list (quote succ) (list (quote succ) (quote succ))))
(macroexpand-1 (quote (pattern [1 2 & * 3])))
(pattern [1 2 & * 3])
(pattern [1 2 ^x & * 3])
(pattern [1 2 & ^x * 3])
(pattern {:foo 1, :bar (& * 3)})
(pattern [1 2 (clojure.core/unquote (or 3 4))])
(pattern [1 2 ^x (clojure.core/unquote (->View (quote foo)))])
((view [1 2 & * 3]) [1 2])
((view [1 2 & * 3]) [1 2 3 3 3])
((view [1 2 & * 3]) [1 2 3 3 3 4])
(pattern [1 2 ^x _])
(macroexpand (quote (pattern [1 2 ^x & _])))
(macroexpand (quote (pattern [1 2 & ^x _])))
((view (clojure.core/unquote (output [1 2 ^x & _] (fnk [x] x)))) [1 2 3 4])
((view (clojure.core/unquote (output [1 2 & ^x _] (fnk [x] x)))) [1 2 3 4])
(pattern (clojure.core/unquote (output [1 2 ^rest & * 3] (fnk [rest] rest))))
(pattern->view (pattern (clojure.core/unquote (output [1 2 ^rest & * 3] (fnk [rest] rest)))))
((view (clojure.core/unquote (output [1 2 ^rest & * 3] (fnk [rest] rest)))) [1 2 3 3 3])
(pattern (clojure.core/unquote (or [(->Bind (quote succ) (->View (quote succ))) (->Bind (quote zero) (->View (quote zero)))])))
(macroexpand-1 (quote (pattern (1 2 3))))
(macroexpand-1 (quote (pattern (succ))))
(def num-graph (graph num (clojure.core/unquote (or (clojure.core/unquote succ) (clojure.core/unquote zero))) succ (succ ^x (clojure.core/unquote num)) zero zero))
(def num-out (output-in num-graph (quote zero) (fnk [] 0) (quote succ) (fnk [x] (inc x))))
(macroexpand-1 (quote (graph foo (clojure.core/unquote foo))))
(def num (eval (graph->view (quote num) num-out)))
(num (quote zero))
(num (quote (succ (succ zero))))
(num (quote (1 (succ zero))))
(num (quote (succ succ)))
(macroexpand-1 (quote (trace-pattern [1 2 3] [1 2 3])))
(macroexpand-1 (quote (trace [1 2 3])))
((trace [1 2 3]) [1 2 3])
(pattern [1 2 3])
(pattern->view (strucjure.debug/pattern-with-print-trace (pattern [1 2 3])))