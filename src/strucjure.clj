(ns strucjure
  (:use clojure.test
        [slingshot.slingshot :only [throw+ try+]])
  (:require clojure.set
            clojure.walk
            strucjure.view
            strucjure.walk))

;; PEG parser / pattern matcher
;; (originally based on matchure)

;; A pattern takes an input and a set of bindings, consumes some or all of the input and returns new bindings
;; A view takes an input, consumes some or all of the input and returns a value
;; A view is constructed from a list of [pattern value] pairs, where the value forms have access to the patterns bindings

;; --- TODO ---
;; better error/failure reporting
;; provide syntax for matching record literals #user.Foo{} and set literals
;; allow optional keys?
;; think about extensibility and memoization
;; use & pattern instead of (& pattern)
;; if make view a protocol, can do things like (regex pattern) for free but lose IFn on compiled views
;; separate into pattern level (ie *-ast) and code level ASTs

;; --- GENSYMS ---
;; We want to be able to recognise symbols generated by strucjure later on when we optimise the resulting code

(defn gensym [name]
  (clojure.core/gensym (str name "__strucjure__")))

(defn gensym? [symbol]
  (re-find #"__strucjure__\d+"))

;; --- THUNKS ---
;; Used to avoid exponential expansion of code in repeated branches

(defn filter-nil [args]
  (vec (filter #(not (= nil %)) args)))

(defn thunkify [thunks args form]
  (let [args (filter-nil args)
        name (gensym "thunk")
        thunk `(~name ~@args)
        thunk-fn `(~name ~(vec args) ~form)]
    (swap! thunks conj thunk-fn)
    thunk))

;; --- COMPILER STAGES ---

(def input-sym '%)

(defn replace-input-sym [input form]
  (clojure.walk/prewalk-replace {input-sym input} form))

;; Views can be registered to modify the clj code produced by the compiler

(def clj->clj* strucjure.view/empty)

(defn clj->clj [clj] clj
  ;;(strucjure.walk/prewalk-expand clj->clj* (clojure.walk/macroexpand-all clj))
  )

;; Views can be registered to modify the low-level AST produced by the compiler

(def last->last* strucjure.view/empty)

(defn last->last [last]
  (strucjure.walk/prewalk-expand last->last* last))

;; Low-level AST forms correspond directly to clj code

(defrecord State [input output bindings thunks])

(defprotocol LAST
  "A low-level Abstract Syntax Tree for a pattern."
  (last->clj* [this state true-case false-case]
    "Output code which tests the pattern against input with the supplied bindings. May add new thunks to the list. The success branch should be ~(true-case rest new-bindings) and the failure branch should be ~false-case."))

(defn last->clj [last state true-case false-case]
  (last->clj* last state true-case false-case))

;; High-level AST forms behave like macros which expand to low-level AST forms

(defprotocol HAST
  "A high-level Abstract Syntax Tree for a pattern"
  (hast->last* [this]
    "Expands to a mixture of HASTs and LASTs. Called recursively, like macroexpansion."))

(defn hast->last [form]
  (if (instance? strucjure.HAST form)
    (hast->last (hast->last* form))
    (strucjure.walk/walk hast->last form)))

;; The pattern syntax is recognised directly by the pattern->hast view

(declare seq-pattern->hast)

(declare pattern->hast)

(declare case->hast) ; defined later using pattern->hast

;; --- COMPILER ---

(defrecord CompiledCase [case fun]
  strucjure.view.View
  (run* [this input true-case false-case]
    (fun input true-case false-case)))

;; Here true-case is (fn [output rest] code), false-case is code
(defn compile-inline [case input bindings true-case false-case wrapper]
  (let [thunks (atom [])
        output (gensym "output")
        bindings (conj bindings input)
        last-true-case (fn [rest _] (true-case output rest))
        state (->State input output bindings thunks)
        start (-> case
                  case->hast
                  hast->last
                  last->last
                  (last->clj state last-true-case false-case))]
    (clj->clj `(letfn [~@@thunks] ~(wrapper start)))))

(defn compile-view [case bindings wrapper]
  (let [input (gensym "input")
        true-cont (gensym "true-cont")
        false-cont (gensym "false-cont")
        bindings (conj bindings true-cont false-cont)
        true-case (fn [output rest] `(~true-cont ~output ~rest))
        false-case `(~false-cont)
        wrapper (fn [start] (wrapper `(->CompiledCase '~(vec case) (fn [~input ~true-cont ~false-cont] ~start))))]
    (compile-inline case input bindings true-case false-case wrapper)))

(defn succeed-inline [case input output rest]
  `(if (= nil ~rest)
     ~output
     (throw+ (strucjure.view/->PartialMatch '~(vec case) ~input ~output ~rest))))

(defn fail-inline [case input]
  `(throw+ (strucjure.view/->NoMatch '~(vec case) ~input)))

(defmacro match [value & case]
  (let [input (gensym "input")]
    (compile-inline case input #{}
                    (partial succeed-inline case input)
                    (fail-inline case input)
                    (fn [start] `(let [~input ~value] ~start)))))

(defmacro view [& case]
  (compile-view case #{} identity))

(defmacro defview [name & case]
  `(def ~name
     ~(compile-view case #{} identity)))

(defmacro defnview [name args & case]
  `(def ~name
     ~(compile-view case (set args) (fn [start] `(fn [~@args] ~start)))))

;; --- LOW-LEVEL AST ---

;; Always succeeds. Consumes and transforms input
(defrecord Leave [form]
  LAST
  (last->clj* [this {:keys [input bindings]} true-case false-case]
    (let [form (replace-input-sym input form)
          left (gensym "left")]
      `(let [~left ~form]
         ~(true-case left (conj bindings left))))))

;; Succeeds if form evaluates to true. Does not consume anything
(defrecord Guard [form]
  LAST
  (last->clj* [this {:keys [input bindings]} true-case false-case]
    `(if ~(replace-input-sym input form)
       ~(true-case input bindings)
       ~false-case)))

;; If symbol is already bound, tests for equality.
;; Otherwise binds input to symbol
;; Always consumes all input
(defrecord Bind [symbol]
  LAST
  (last->clj* [this {:keys [input bindings]} true-case false-case]
    (if (contains? bindings symbol)
      ;; test for equality
      `(if (= ~symbol ~input)
         ~(true-case nil bindings)
         ~false-case)
      ;; bind symbol
      `(let [~symbol ~input]
         ~(true-case nil (conj bindings symbol))))))

;; Calls the view with the current input and runs pattern on its output
;; The pattern must consume the whole output
(defrecord Import* [view pattern]
  LAST
  (last->clj* [this {:keys [input bindings thunks] :as state} true-case false-case]
    (let [import (gensym "import")
          rest (gensym "rest")
          pattern-true-case (fn [_ new-bindings]
                              (true-case rest (conj new-bindings rest)))
          pattern-false-case (thunkify thunks (conj bindings input) false-case)
          view-true-case  `(fn [~import ~rest]
                             ~(last->clj pattern (assoc state :input import) pattern-true-case pattern-false-case))
          view-false-case `(fn [] ~pattern-false-case)]
      `(strucjure.view/run ~view ~input ~view-true-case ~view-false-case))))

;; All patterns get the same input
;; All bindings are exported
;; The output is the output from the last pattern
(defrecord And* [pattern-a pattern-b]
  LAST
  (last->clj* [this {:keys [bindings thunks] :as state} true-case false-case]
    (let [false-case (thunkify thunks bindings false-case)]
    (last->clj pattern-a state
               (fn [rest new-bindings]
                 (last->clj pattern-b state true-case false-case))
               false-case))))

;; Each pattern gets the remaining input from the last pattern
;; All bindings are exported
;; The output is the output from the last pattern
(defrecord Seq* [pattern-a pattern-b]
  LAST
  (last->clj* [this {:keys [bindings thunks] :as state} true-case false-case]
    (let [false-case (thunkify thunks bindings false-case)]
      (last->clj pattern-a state
                (fn [rest new-bindings]
                  (last->clj pattern-b
                             (assoc state :input rest :bindings (conj new-bindings rest))
                             true-case false-case))
                false-case))))

;; This is really hacky :(
;; When compiling Or we need to compile the args to find out what the bindings are for true-case
;; But we need a true-case to compile the args
;; So we pass in a placeholder, grab its arguments and replace it later
(defn with-dummy-true-case [pattern state true-case-rest false-case]
  (let [rest-atom (atom nil)
        bindings-atom (atom nil)
        placeholder (gensym "true-case-placeholder")
        true-case-dummy (fn [rest bindings]
                          (compare-and-set! rest-atom nil rest)
                          (compare-and-set! bindings-atom nil bindings)
                          placeholder)
        clj (last->clj pattern state true-case-dummy false-case)
        replace (fn [form true-case-thunk]
                  (clojure.walk/prewalk-replace
                   {placeholder (clojure.walk/prewalk-replace {true-case-rest @rest-atom} true-case-thunk)}
                   form))]
    [clj replace @bindings-atom]))

;; Each pattern gets the same input
;; Only bindings that are created in both branches are exported
;; The output is the output from the first successful pattern
(defrecord Or* [pattern-a pattern-b]
  LAST
  (last->clj* [this {:keys [bindings thunks] :as state} true-case false-case]
    (let [true-case-rest (gensym "true-case-rest")
          [clj-b replace-b bindings-b] (with-dummy-true-case pattern-b state true-case-rest false-case)
          [clj-a replace-a bindings-a] (with-dummy-true-case pattern-a state true-case-rest clj-b)
          true-case-bindings (conj (clojure.set/intersection bindings-a bindings-b) true-case-rest)
          true-case-thunk (thunkify thunks true-case-bindings (true-case true-case-rest true-case-bindings))]
      (swap! thunks replace-b true-case-thunk)
      (swap! thunks replace-a true-case-thunk)
      (replace-a (replace-b clj-a true-case-thunk) true-case-thunk))))

;; Fails if the inner pattern succeeds and vice versa
;; No bindings are exported (TODO: allow exporting not-bindings)
;; The input is consumed
(defrecord Not [pattern]
  LAST
  (last->clj* [this {:keys [bindings] :as state} true-case false-case]
    (last->clj pattern state
              (fn [_ _] false-case)
              (true-case nil bindings))))

;; Binds output for views
(defrecord Return [value]
  LAST
  (last->clj* [this {:keys [input output bindings]} true-case false-case]
    `(let [~output ~value]
       ~(true-case input (conj bindings output)))))

;; --- HIGH-LEVEL AST ---

(defrecord Or [patterns]
  HAST
  (hast->last* [this]
    (reduce ->Or* patterns)))

(defrecord And [patterns]
  HAST
  (hast->last* [this]
    (reduce ->And* patterns)))

(defrecord Seq [patterns]
  HAST
  (hast->last* [this]
    (reduce ->Seq* patterns)))

(defn or-ast [& patterns] (->Or patterns))
(defn and-ast [& patterns] (->And patterns))
(defn seq-ast [& patterns] (->Seq patterns))

(defrecord GuardNil []
  HAST
  (hast->last* [this]
    (->Guard `(= nil ~input-sym))))

(defrecord Import [view pattern]
  HAST
  (hast->last* [this]
    (->Import* view (seq-ast pattern (->GuardNil)))))

(defrecord Literal [literal]
  HAST
  (hast->last* [this]
    (->Seq [(->Guard `(= ~literal ~input-sym))
            (->Leave nil)])))

(defrecord Head [pattern]
  HAST
  (hast->last* [this]
    (seq-ast (->Guard `(not= nil ~input-sym))
             (and-ast (seq-ast (->Leave `(first ~input-sym))
                               pattern
                               (->GuardNil))
                      (->Leave `(next ~input-sym))))))

(defrecord Instance [class-name]
  HAST
  (hast->last* [this]
    (seq-ast (->Guard `(instance? ~class-name ~input-sym))
             (->Leave nil))))

(defrecord Prefix [patterns]
  HAST
  (hast->last* [this]
    (->Seq
     (flatten
      [(->Guard `(or (instance? clojure.lang.Seqable ~input-sym) (nil? ~input-sym)))
       (->Leave `(seq ~input-sym))
       (into [] patterns)]))))

(defn prefix-ast [& patterns] (->Prefix patterns))

(defrecord Seqable [patterns]
  HAST
  (hast->last* [this]
    (seq-ast
     (->Prefix patterns)
     (->GuardNil))))

(defn seqable-ast [& patterns] (->Seqable patterns))

(defrecord Key [key pattern]
  HAST
  (hast->last* [this]
    (seq-ast
     (->Leave `(get ~input-sym ~key ::not-found))
     (->Guard `(not= ::not-found ~input-sym))
     pattern
     (->GuardNil))))

(defrecord Map [keys&patterns]
  HAST
  (hast->last* [this]
    (->And (cons
            (->Guard `(instance? clojure.lang.Associative ~input-sym))
            (for [[key pattern] keys&patterns]
              (->Key key pattern))))))

(defrecord Regex [regex]
  HAST
  (hast->last* [this]
    (and-ast
     (->Guard `(not= nil (re-find ~regex ~input-sym)))
     (->Leave nil))))

(defrecord Predicate [predicate]
  HAST
  (hast->last* [this]
    (and-ast
     (->Guard predicate)
     (->Leave nil))))

(defrecord Constructor [constructor arg-patterns]
  HAST
  (hast->last* [this]
    (and-ast
     (->Instance constructor)
     (seq-ast
      (->Leave `(vals ~input-sym))
      (->Seqable (map ->Head arg-patterns))))))

;; --- PARSER UTILS ---

(defn primitive? [value]
  (or (#{nil true false} value)
      (number? value)
      (string? value)
      (char? value)
      (keyword? value)))

(defn binding? [value]
  (and (symbol? value)
       (re-find #"^\?(.+)$" (name value))))

(defn binding-name [value]
  (let [[_ string] (re-find #"^\?(.+)$" (name value))]
    (symbol string)))

(defn constructor? [value]
  (and (symbol? value)
       (re-find #"^(.+)\.$" (name value))))

(defn constructor-name [value]
  (let [[_ string] (re-find #"^(.+)\.$" (name value))]
    (symbol string)))

(defn class-name? [value]
  (and (symbol? value)
       (re-find #"^\A(?:[a-z0-9\-]+\.)*[A-Z]\w*\Z$" (name value))))

(defn predicate? [value]
  (and (symbol? value)
       (.endsWith (name value) "?")))

;; --- BOOTSTRAP PARSER ---
;; we write HASTs directly to build up a basic parser and then use that to write the real parser

;; temporary definition, until we have a basic parser
(defn case->hast [hasts&values]
  (assert (even? (count hasts&values)))
  (->Or
   (for [[hast value] (partition 2 hasts&values)]
     (seq-ast (eval hast) (->Return value)))))

(defnview zero-or-more [elem]
  (prefix-ast (->Head (->Import 'elem (->Bind 'x)))
              (->Import '(zero-or-more elem) (->Bind 'xs)))
  (cons x xs)

  (prefix-ast)
  nil)

(defnview two-or-more [elem]
  (prefix-ast (->Head (->Import 'elem (->Bind 'x1)))
              (->Head (->Import 'elem (->Bind 'x2)))
              (->Import '(zero-or-more elem) (->Bind 'xs)))
  (cons x1 (cons x2 xs)))

(defnview zero-or-more-prefix [elem]
  (prefix-ast (->Import 'elem (->Bind 'x))
              (->Import '(zero-or-more-prefix elem) (->Bind 'xs)))
  (cons x xs)

  (prefix-ast)
  nil)

(defview seq-pattern->hast
  ;; & PATTERNS

  (prefix-ast (->Head (->Literal ''&))
              (->Head (->Import 'pattern->hast (->Bind 'pattern))))
  pattern

  ;; ESCAPED PATTERNS

  (prefix-ast (->Head (->Import 'pattern->hast (->Bind 'pattern))))
  (->Head pattern))

(defview pattern->hast
  ;; BINDINGS

  (and-ast (->Predicate `(binding? ~input-sym))
           (->Bind 'binding))
  (->Bind (binding-name binding))

  ;; LITERALS

  (and-ast (->Predicate `(primitive? ~input-sym))
           (->Bind 'primitive))
  (->Literal primitive)

  (and-ast (->Predicate `(class-name? ~input-sym))
           (->Bind 'class-name))
  (->Instance class-name)

  ;; PREDICATES

  (and-ast (->Predicate `(predicate? ~input-sym))
           (->Bind 'predicate))
  (->Predicate `(~predicate ~input-sym))

  ;; SEQUENCES

  (and-ast (->Predicate `(vector? ~input-sym))
           (seqable-ast (->Import '(zero-or-more-prefix seq-pattern->hast) (->Bind 'seq-patterns))))
  (->Seqable seq-patterns)

  (and-ast (->Predicate `(seq? ~input-sym))
           (seqable-ast (->Head (->Literal ''prefix))
                        (->Import '(zero-or-more-prefix seq-pattern->hast) (->Bind 'seq-patterns))))
  (->Prefix seq-patterns)

  ;; SPECIAL FORMS

  (and-ast (->Predicate `(seq? ~input-sym))
           (seqable-ast (->Head (->Literal ''quote))
                        (->Head (->Bind 'quoted))))
  (->Literal `(quote ~quoted))

  (and-ast (->Predicate `(seq? ~input-sym))
           (seqable-ast (->Head (->Literal ''and))
                        (->Import '(two-or-more pattern->hast) (->Bind 'patterns))))
  (->And patterns)

  (and-ast (->Predicate `(seq? ~input-sym))
           (seqable-ast (->Head (->Literal ''or))
                        (->Import '(two-or-more pattern->hast) (->Bind 'patterns))))
  (->Or patterns)

  ;; IMPORTED VIEWS

  (and-ast (->Predicate `(seq? ~input-sym))
           (seqable-ast (->Head (->Bind 'view))
                        (->Head (->Import 'pattern->hast (->Bind 'pattern)))))
  (->Import view pattern))

;; --- REAL PARSER ---
(comment)
(defn case->hast [patterns&values]
  (assert (even? (count patterns&values)))
  (->Or
   (for [[pattern value] (partition 2 patterns&values)]
     (seq-ast (strucjure.view/run pattern->hast pattern) (->Return value)))))

(defnview optional [elem]
  (prefix (elem ?x)) x
  (prefix) nil)

(defnview zero-or-more [elem]
  (prefix (elem ?x) & ((zero-or-more elem) ?xs)) (cons x xs)
  (prefix) nil)

(defnview one-or-more [elem]
  (prefix (elem ?x) & ((zero-or-more elem) ?xs)) (cons x xs))

(defnview two-or-more [elem]
  (prefix (elem ?x1) (elem ?x2) & ((zero-or-more elem) ?xs)) (cons x1 (cons x2 xs)))

(defnview zero-or-more-prefix [elem]
  (prefix & (elem ?x) & ((zero-or-more-prefix elem) ?xs)) (cons x xs)
  (prefix) nil)

(defnview one-or-more-prefix [elem]
  (prefix & (elem ?x) & ((zero-or-more-prefix elem) ?xs)) (cons x xs))

(defview key&pattern->hast
  [?key (pattern->hast ?pattern)] [key pattern])

(defview seq-pattern->hast
  ;; & PATTERNS
  (prefix '& (pattern->hast ?pattern)) pattern

  ;; ESCAPED PATTERNS
  (prefix (and seq? ['guard ?form])) (->Guard form)

  ;; ALL OTHER PATTERNS
  (prefix (pattern->hast ?pattern)) (->Head pattern))

(defview pattern->hast
  ;; BINDINGS
  '_ (->Leave nil)
  (and binding? ?binding) (->Bind (binding-name binding))

  ;; LITERALS
  (and primitive? ?primitive) (->Literal primitive) ; primitives evaluate to themselves, so don't need quoting
  (and class-name? ?class-name) (->Instance class-name)
  (and (or clojure.lang.PersistentArrayMap clojure.lang.PersistentHashMap) [& ((zero-or-more key&pattern->hast) ?keys&patterns)])
    (->Map keys&patterns)
  (and seq? [(and constructor? ?constructor) & ((zero-or-more pattern->hast) ?arg-patterns)])
    (->Constructor (constructor-name constructor) arg-patterns)

  ;; PREDICATES
  (and java.util.regex.Pattern ?regex) (->Regex regex)
  (and predicate? ?predicate) (->Predicate `(~predicate ~input-sym))
  (and seq? [(or 'fn 'fn*) [] & ?body]) (->Predicate `(do ~@body))
  (and seq? [(or 'fn 'fn*) [?arg] & ?body]) (->Predicate `(do ~@(clojure.walk/prewalk-replace {arg input-sym} body)))

  ;; SEQUENCES
  (and vector? [& ((zero-or-more-prefix seq-pattern->hast) ?seq-patterns)]) (->Seqable seq-patterns)
  (and seq? ['prefix & ((zero-or-more-prefix seq-pattern->hast) ?seq-patterns)]) (->Prefix seq-patterns)

  ;; SPECIAL FORMS
  (and seq? ['quote ?quoted]) (->Literal `(quote ~quoted))
  (and seq? ['guard ?form]) (->Guard form)
  (and seq? ['leave ?form]) (->Leave form)
  (and seq? ['and & ((two-or-more pattern->hast) ?patterns)]) (->And patterns)
  (and seq? ['seq & ((two-or-more pattern->hast) ?patterns)]) (->Seq patterns)
  (and seq? ['or & ((two-or-more pattern->hast) ?patterns)]) (->Or patterns)
  (and seq? ['not (pattern->hast ?pattern)]) (->Not pattern)

  ;; EXTERNAL VARIABLES
  (and symbol? ?variable) (->Literal variable)

  ;; IMPORTED VIEWS
  (and seq? [?view (pattern->hast ?pattern)]) (->Import view pattern))

;; --- OPTIMISERS ---

(defn symbols [form]
  (cond
   (symbol? form) #{form}
   (instance? clojure.lang.Seqable form) (apply clojure.set/union (map symbols form))
   :else #{}))

(defn filter-used [args form]
  (vec (filter (symbols form) args)))
