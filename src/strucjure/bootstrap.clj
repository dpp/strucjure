(ns strucjure.bootstrap)

;; Pre-compiled parsers to bootstrap strucjure's syntax

(do (def optional (quote (clojure.core/fn [elem] (strucjure/->Match (clojure.core/fn [input__10351 true-cont__10352 false-cont__10353] (clojure.core/let [thunk__10357 (clojure.core/fn [] (if (clojure.core/let [% input__10351] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10355 (clojure.core/let [% input__10351] (clojure.core/seq %))] (clojure.core/let [rest left__10355] (clojure.core/let [left__10356 (clojure.core/let [% input__10351] rest)] (clojure.core/let [output__10354 (clojure.core/let [% left__10356] nil)] (true-cont__10352 output__10354 left__10356))))) (false-cont__10353)))] (if (clojure.core/let [% input__10351] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10358 (clojure.core/let [% input__10351] (clojure.core/seq %))] (clojure.core/if-let [[head__10359 & tail__10360] left__10358] ((.match-fn elem) head__10359 (clojure.core/fn [output__10361 rest__10362] (clojure.core/let [x output__10361] (if (clojure.core/= nil rest__10362) (clojure.core/let [rest tail__10360] (clojure.core/let [left__10363 (clojure.core/let [% input__10351] rest)] (clojure.core/let [output__10354 (clojure.core/let [% left__10363] x)] (true-cont__10352 output__10354 left__10363)))) (thunk__10357)))) thunk__10357) (thunk__10357))) (thunk__10357)))))))) (def zero-or-more (quote (clojure.core/fn [elem] (strucjure/->Match (clojure.core/fn [input__10364 true-cont__10365 false-cont__10366] (clojure.core/let [thunk__10370 (clojure.core/fn [] (if (clojure.core/let [% input__10364] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10368 (clojure.core/let [% input__10364] (clojure.core/seq %))] (clojure.core/let [rest left__10368] (clojure.core/let [left__10369 (clojure.core/let [% input__10364] rest)] (clojure.core/let [output__10367 (clojure.core/let [% left__10369] nil)] (true-cont__10365 output__10367 left__10369))))) (false-cont__10366)))] (if (clojure.core/let [% input__10364] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10371 (clojure.core/let [% input__10364] (clojure.core/seq %))] (clojure.core/if-let [[head__10372 & tail__10373] left__10371] ((.match-fn elem) head__10372 (clojure.core/fn [output__10374 rest__10375] (clojure.core/let [x output__10374] (if (clojure.core/= nil rest__10375) ((.match-fn (zero-or-more elem)) tail__10373 (clojure.core/fn [output__10376 rest__10377] (clojure.core/let [xs output__10376] (clojure.core/let [rest rest__10377] (clojure.core/let [left__10378 (clojure.core/let [% input__10364] rest)] (clojure.core/let [output__10367 (clojure.core/let [% left__10378] (cons x xs))] (true-cont__10365 output__10367 left__10378)))))) thunk__10370) (thunk__10370)))) thunk__10370) (thunk__10370))) (thunk__10370)))))))) (def one-or-more (quote (clojure.core/fn [elem] (strucjure/->Match (clojure.core/fn [input__10379 true-cont__10380 false-cont__10381] (if (clojure.core/let [% input__10379] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10383 (clojure.core/let [% input__10379] (clojure.core/seq %))] (clojure.core/if-let [[head__10384 & tail__10385] left__10383] ((.match-fn elem) head__10384 (clojure.core/fn [output__10386 rest__10387] (clojure.core/let [x output__10386] (if (clojure.core/= nil rest__10387) ((.match-fn (zero-or-more elem)) tail__10385 (clojure.core/fn [output__10388 rest__10389] (clojure.core/let [xs output__10388] (clojure.core/let [rest rest__10389] (clojure.core/let [left__10390 (clojure.core/let [% input__10379] rest)] (clojure.core/let [output__10382 (clojure.core/let [% left__10390] (cons x xs))] (true-cont__10380 output__10382 left__10390)))))) false-cont__10381) (false-cont__10381)))) false-cont__10381) (false-cont__10381))) (false-cont__10381))))))) (def pattern (quote (strucjure/->Match (clojure.core/fn [input__10391 true-cont__10392 false-cont__10393] (if (clojure.core/= input__10391 (quote _)) (clojure.core/let [output__10394 (clojure.core/let [% nil] (->Bind (quote _)))] (true-cont__10392 output__10394 nil)) (clojure.core/let [thunk__10439 (clojure.core/fn [] (clojure.core/let [thunk__10438 (clojure.core/fn [] (clojure.core/let [thunk__10437 (clojure.core/fn [] (clojure.core/let [thunk__10433 (clojure.core/fn [] (clojure.core/let [thunk__10427 (clojure.core/fn [] (clojure.core/let [thunk__10421 (clojure.core/fn [] (clojure.core/let [thunk__10415 (clojure.core/fn [] (clojure.core/let [thunk__10409 (clojure.core/fn [] (clojure.core/let [thunk__10403 (clojure.core/fn [] (clojure.core/let [thunk__10402 (clojure.core/fn [] (if (clojure.core/let [% input__10391] (seq? %)) (if (clojure.core/let [% input__10391] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10395 (clojure.core/let [% input__10391] (clojure.core/seq %))] (clojure.core/if-let [[head__10396 & tail__10397] left__10395] (clojure.core/let [match head__10396] (clojure.core/if-let [[head__10398 & tail__10399] tail__10397] ((.match-fn pattern) head__10398 (clojure.core/fn [output__10400 rest__10401] (clojure.core/let [pattern output__10400] (if (clojure.core/= nil rest__10401) (if (clojure.core/= nil tail__10399) (clojure.core/let [output__10394 (clojure.core/let [% nil] (->Import match (->Seq [pattern (->GuardNil)])))] (true-cont__10392 output__10394 nil)) (false-cont__10393)) (false-cont__10393)))) false-cont__10393) (false-cont__10393))) (false-cont__10393))) (false-cont__10393)) (false-cont__10393)))] (if (clojure.core/let [% input__10391] (symbol? %)) (clojure.core/let [variable input__10391] (clojure.core/let [output__10394 (clojure.core/let [% nil] (->Literal variable))] (true-cont__10392 output__10394 nil))) (thunk__10402))))] (if (clojure.core/let [% input__10391] (seq? %)) (if (clojure.core/let [% input__10391] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10404 (clojure.core/let [% input__10391] (clojure.core/seq %))] (clojure.core/if-let [[head__10405 & tail__10406] left__10404] (if (clojure.core/= head__10405 (quote or)) ((.match-fn (one-or-more pattern)) tail__10406 (clojure.core/fn [output__10407 rest__10408] (clojure.core/let [patterns output__10407] (if (clojure.core/= nil rest__10408) (clojure.core/let [output__10394 (clojure.core/let [% nil] (->Or patterns))] (true-cont__10392 output__10394 nil)) (thunk__10403)))) thunk__10403) (thunk__10403)) (thunk__10403))) (thunk__10403)) (thunk__10403))))] (if (clojure.core/let [% input__10391] (seq? %)) (if (clojure.core/let [% input__10391] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10410 (clojure.core/let [% input__10391] (clojure.core/seq %))] (clojure.core/if-let [[head__10411 & tail__10412] left__10410] (if (clojure.core/= head__10411 (quote and)) ((.match-fn (one-or-more pattern)) tail__10412 (clojure.core/fn [output__10413 rest__10414] (clojure.core/let [patterns output__10413] (if (clojure.core/= nil rest__10414) (clojure.core/let [output__10394 (clojure.core/let [% nil] (->And patterns))] (true-cont__10392 output__10394 nil)) (thunk__10409)))) thunk__10409) (thunk__10409)) (thunk__10409))) (thunk__10409)) (thunk__10409))))] (if (clojure.core/let [% input__10391] (seq? %)) (if (clojure.core/let [% input__10391] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10416 (clojure.core/let [% input__10391] (clojure.core/seq %))] (clojure.core/if-let [[head__10417 & tail__10418] left__10416] (if (clojure.core/= head__10417 (quote leave)) (clojure.core/if-let [[head__10419 & tail__10420] tail__10418] (clojure.core/let [form head__10419] (if (clojure.core/= nil tail__10420) (clojure.core/let [output__10394 (clojure.core/let [% nil] (->Leave form))] (true-cont__10392 output__10394 nil)) (thunk__10415))) (thunk__10415)) (thunk__10415)) (thunk__10415))) (thunk__10415)) (thunk__10415))))] (if (clojure.core/let [% input__10391] (seq? %)) (if (clojure.core/let [% input__10391] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10422 (clojure.core/let [% input__10391] (clojure.core/seq %))] (clojure.core/if-let [[head__10423 & tail__10424] left__10422] (if (clojure.core/= head__10423 (quote guard)) (clojure.core/if-let [[head__10425 & tail__10426] tail__10424] (clojure.core/let [form head__10425] (if (clojure.core/= nil tail__10426) (clojure.core/let [output__10394 (clojure.core/let [% nil] (->Guard form))] (true-cont__10392 output__10394 nil)) (thunk__10421))) (thunk__10421)) (thunk__10421)) (thunk__10421))) (thunk__10421)) (thunk__10421))))] (if (clojure.core/let [% input__10391] (seq? %)) (if (clojure.core/let [% input__10391] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10428 (clojure.core/let [% input__10391] (clojure.core/seq %))] (clojure.core/if-let [[head__10429 & tail__10430] left__10428] (if (clojure.core/= head__10429 (quote quote)) (clojure.core/if-let [[head__10431 & tail__10432] tail__10430] (clojure.core/let [quoted head__10431] (if (clojure.core/= nil tail__10432) (clojure.core/let [output__10394 (clojure.core/let [% nil] (->Literal (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list quoted)))))] (true-cont__10392 output__10394 nil)) (thunk__10427))) (thunk__10427)) (thunk__10427)) (thunk__10427))) (thunk__10427)) (thunk__10427))))] (if (clojure.core/let [% input__10391] (vector? %)) (if (clojure.core/let [% input__10391] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10434 (clojure.core/let [% input__10391] (clojure.core/seq %))] ((.match-fn (zero-or-more seq-pattern)) left__10434 (clojure.core/fn [output__10435 rest__10436] (clojure.core/let [seq-patterns output__10435] (if (clojure.core/= nil rest__10436) (clojure.core/let [output__10394 (clojure.core/let [% nil] (seq-ast seq-patterns))] (true-cont__10392 output__10394 nil)) (thunk__10433)))) thunk__10433)) (thunk__10433)) (thunk__10433))))] (if (clojure.core/let [% input__10391] (class-name? %)) (clojure.core/let [class input__10391] (clojure.core/let [output__10394 (clojure.core/let [% nil] (->And [(->Guard (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/instance?)) (clojure.core/list class) (clojure.core/list input-sym)))) (->Bind (quote _))]))] (true-cont__10392 output__10394 nil))) (thunk__10437))))] (if (clojure.core/let [% input__10391] (primitive? %)) (clojure.core/let [literal input__10391] (clojure.core/let [output__10394 (clojure.core/let [% nil] (->Literal literal))] (true-cont__10392 output__10394 nil))) (thunk__10438))))] (if (clojure.core/let [% input__10391] (binding? %)) (clojure.core/let [binding input__10391] (clojure.core/let [output__10394 (clojure.core/let [% nil] (->Bind (binding-name binding)))] (true-cont__10392 output__10394 nil))) (thunk__10439)))))))) (def seq-pattern (quote (strucjure/->Match (clojure.core/fn [input__10440 true-cont__10441 false-cont__10442] (clojure.core/let [thunk__10452 (clojure.core/fn [] (clojure.core/let [thunk__10446 (clojure.core/fn [] ((.match-fn pattern) input__10440 (clojure.core/fn [output__10444 rest__10445] (clojure.core/let [pattern output__10444] (clojure.core/let [output__10443 (clojure.core/let [% rest__10445] (->Head (->Seq [pattern (->GuardNil)])))] (true-cont__10441 output__10443 rest__10445)))) false-cont__10442))] (if (clojure.core/let [% input__10440] (seq? %)) (if (clojure.core/let [% input__10440] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10447 (clojure.core/let [% input__10440] (clojure.core/seq %))] (clojure.core/if-let [[head__10448 & tail__10449] left__10447] (if (clojure.core/= head__10448 (quote guard)) (clojure.core/if-let [[head__10450 & tail__10451] tail__10449] (clojure.core/let [form head__10450] (if (clojure.core/= nil tail__10451) (clojure.core/let [output__10443 (clojure.core/let [% nil] (->Guard form))] (true-cont__10441 output__10443 nil)) (thunk__10446))) (thunk__10446)) (thunk__10446)) (thunk__10446))) (thunk__10446)) (thunk__10446))))] (if (clojure.core/let [% input__10440] (seq? %)) (if (clojure.core/let [% input__10440] (or (instance? clojure.lang.Seqable %) (nil? %))) (clojure.core/let [left__10453 (clojure.core/let [% input__10440] (clojure.core/seq %))] (clojure.core/if-let [[head__10454 & tail__10455] left__10453] (if (clojure.core/= head__10454 (quote &)) (clojure.core/if-let [[head__10456 & tail__10457] tail__10455] ((.match-fn pattern) head__10456 (clojure.core/fn [output__10458 rest__10459] (clojure.core/let [pattern output__10458] (if (clojure.core/= nil rest__10459) (if (clojure.core/= nil tail__10457) (clojure.core/let [output__10443 (clojure.core/let [% nil] pattern)] (true-cont__10441 output__10443 nil)) (thunk__10452)) (thunk__10452)))) thunk__10452) (thunk__10452)) (thunk__10452)) (thunk__10452))) (thunk__10452)) (thunk__10452))))))))
