(ns strucjure.bootstrap)

;; Pre-compiled parsers to bootstrap strucjure's syntax
(def optional '(clojure.core/letfn [(thunk__1976 [elem input__1971 true-cont__1972 false-cont__1973] (if (or (instance? clojure.lang.Seqable input__1971) (nil? input__1971)) (clojure.core/let [left__1975 (clojure.core/seq input__1971)] (clojure.core/let [rest left__1975] (clojure.core/let [output__1974 nil] (.invoke true-cont__1972 output__1974 rest)))) (.invoke false-cont__1973)))] (clojure.core/fn [elem] (strucjure/->Match (clojure.core/fn [input__1971 true-cont__1972 false-cont__1973] (if (or (instance? clojure.lang.Seqable input__1971) (nil? input__1971)) (clojure.core/let [left__1977 (clojure.core/seq input__1971)] (if (clojure.core/not= nil left__1977) (clojure.core/let [left__1978 (clojure.core/first left__1977)] ((.match-fn elem) left__1978 (clojure.core/fn [output__1979 rest__1980] (clojure.core/let [x output__1979] (if (clojure.core/= nil rest__1980) (clojure.core/let [left__1981 (clojure.core/next left__1977)] (clojure.core/let [rest left__1981] (clojure.core/let [output__1974 x] (.invoke true-cont__1972 output__1974 rest)))) (thunk__1976 elem input__1971 true-cont__1972 false-cont__1973)))) (clojure.core/fn [] (thunk__1976 elem input__1971 true-cont__1972 false-cont__1973)))) (thunk__1976 elem input__1971 true-cont__1972 false-cont__1973))) (thunk__1976 elem input__1971 true-cont__1972 false-cont__1973))))))) (def zero-or-more '(clojure.core/letfn [(thunk__1987 [elem input__1982 true-cont__1983 false-cont__1984] (if (or (instance? clojure.lang.Seqable input__1982) (nil? input__1982)) (clojure.core/let [left__1986 (clojure.core/seq input__1982)] (clojure.core/let [rest left__1986] (clojure.core/let [output__1985 nil] (.invoke true-cont__1983 output__1985 rest)))) (.invoke false-cont__1984)))] (clojure.core/fn [elem] (strucjure/->Match (clojure.core/fn [input__1982 true-cont__1983 false-cont__1984] (if (or (instance? clojure.lang.Seqable input__1982) (nil? input__1982)) (clojure.core/let [left__1988 (clojure.core/seq input__1982)] (if (clojure.core/not= nil left__1988) (clojure.core/let [left__1989 (clojure.core/first left__1988)] ((.match-fn elem) left__1989 (clojure.core/fn [output__1990 rest__1991] (clojure.core/let [x output__1990] (if (clojure.core/= nil rest__1991) (clojure.core/let [left__1992 (clojure.core/next left__1988)] ((.match-fn (zero-or-more elem)) left__1992 (clojure.core/fn [output__1993 rest__1994] (clojure.core/let [xs output__1993] (clojure.core/let [rest rest__1994] (clojure.core/let [output__1985 (cons x xs)] (.invoke true-cont__1983 output__1985 rest))))) (clojure.core/fn [] (thunk__1987 elem input__1982 true-cont__1983 false-cont__1984)))) (thunk__1987 elem input__1982 true-cont__1983 false-cont__1984)))) (clojure.core/fn [] (thunk__1987 elem input__1982 true-cont__1983 false-cont__1984)))) (thunk__1987 elem input__1982 true-cont__1983 false-cont__1984))) (thunk__1987 elem input__1982 true-cont__1983 false-cont__1984))))))) (def one-or-more '(clojure.core/letfn [] (clojure.core/fn [elem] (strucjure/->Match (clojure.core/fn [input__1995 true-cont__1996 false-cont__1997] (if (or (instance? clojure.lang.Seqable input__1995) (nil? input__1995)) (clojure.core/let [left__1999 (clojure.core/seq input__1995)] (if (clojure.core/not= nil left__1999) (clojure.core/let [left__2000 (clojure.core/first left__1999)] ((.match-fn elem) left__2000 (clojure.core/fn [output__2001 rest__2002] (clojure.core/let [x output__2001] (if (clojure.core/= nil rest__2002) (clojure.core/let [left__2003 (clojure.core/next left__1999)] ((.match-fn (zero-or-more elem)) left__2003 (clojure.core/fn [output__2004 rest__2005] (clojure.core/let [xs output__2004] (clojure.core/let [rest rest__2005] (clojure.core/let [output__1998 (cons x xs)] (.invoke true-cont__1996 output__1998 rest))))) (clojure.core/fn [] (.invoke false-cont__1997)))) (.invoke false-cont__1997)))) (clojure.core/fn [] (.invoke false-cont__1997)))) (.invoke false-cont__1997))) (.invoke false-cont__1997))))))) (def pattern '(clojure.core/letfn [(thunk__2017 [input__2006 true-cont__2007 false-cont__2008] (if (seq? input__2006) (if (or (instance? clojure.lang.Seqable input__2006) (nil? input__2006)) (clojure.core/let [left__2010 (clojure.core/seq input__2006)] (if (clojure.core/not= nil left__2010) (clojure.core/let [left__2011 (clojure.core/first left__2010)] (clojure.core/let [match left__2011] (clojure.core/let [left__2012 (clojure.core/next left__2010)] (if (clojure.core/not= nil left__2012) (clojure.core/let [left__2013 (clojure.core/first left__2012)] ((.match-fn pattern) left__2013 (clojure.core/fn [output__2014 rest__2015] (clojure.core/let [pattern output__2014] (if (clojure.core/= nil rest__2015) (clojure.core/let [left__2016 (clojure.core/next left__2012)] (if (clojure.core/= nil left__2016) (clojure.core/let [output__2009 (import-ast match pattern)] (.invoke true-cont__2007 output__2009 nil)) (.invoke false-cont__2008))) (.invoke false-cont__2008)))) (clojure.core/fn [] (.invoke false-cont__2008)))) (.invoke false-cont__2008))))) (.invoke false-cont__2008))) (.invoke false-cont__2008)) (.invoke false-cont__2008))) (thunk__2018 [input__2006 true-cont__2007 false-cont__2008] (if (symbol? input__2006) (clojure.core/let [variable input__2006] (clojure.core/let [output__2009 (literal-ast variable)] (.invoke true-cont__2007 output__2009 nil))) (thunk__2017 input__2006 true-cont__2007 false-cont__2008))) (thunk__2024 [input__2006 true-cont__2007 false-cont__2008] (if (seq? input__2006) (if (or (instance? clojure.lang.Seqable input__2006) (nil? input__2006)) (clojure.core/let [left__2019 (clojure.core/seq input__2006)] (if (clojure.core/not= nil left__2019) (clojure.core/let [left__2020 (clojure.core/first left__2019)] (if (clojure.core/= (quote seq) left__2020) (clojure.core/let [left__2021 (clojure.core/next left__2019)] ((.match-fn (one-or-more pattern)) left__2021 (clojure.core/fn [output__2022 rest__2023] (clojure.core/let [patterns output__2022] (if (clojure.core/= nil rest__2023) (clojure.core/let [output__2009 (apply seq-ast patterns)] (.invoke true-cont__2007 output__2009 nil)) (thunk__2018 input__2006 true-cont__2007 false-cont__2008)))) (clojure.core/fn [] (thunk__2018 input__2006 true-cont__2007 false-cont__2008)))) (thunk__2018 input__2006 true-cont__2007 false-cont__2008))) (thunk__2018 input__2006 true-cont__2007 false-cont__2008))) (thunk__2018 input__2006 true-cont__2007 false-cont__2008)) (thunk__2018 input__2006 true-cont__2007 false-cont__2008))) (thunk__2030 [input__2006 true-cont__2007 false-cont__2008] (if (seq? input__2006) (if (or (instance? clojure.lang.Seqable input__2006) (nil? input__2006)) (clojure.core/let [left__2025 (clojure.core/seq input__2006)] (if (clojure.core/not= nil left__2025) (clojure.core/let [left__2026 (clojure.core/first left__2025)] (if (clojure.core/= (quote and) left__2026) (clojure.core/let [left__2027 (clojure.core/next left__2025)] ((.match-fn (one-or-more pattern)) left__2027 (clojure.core/fn [output__2028 rest__2029] (clojure.core/let [patterns output__2028] (if (clojure.core/= nil rest__2029) (clojure.core/let [output__2009 (apply and-ast patterns)] (.invoke true-cont__2007 output__2009 nil)) (thunk__2024 input__2006 true-cont__2007 false-cont__2008)))) (clojure.core/fn [] (thunk__2024 input__2006 true-cont__2007 false-cont__2008)))) (thunk__2024 input__2006 true-cont__2007 false-cont__2008))) (thunk__2024 input__2006 true-cont__2007 false-cont__2008))) (thunk__2024 input__2006 true-cont__2007 false-cont__2008)) (thunk__2024 input__2006 true-cont__2007 false-cont__2008))) (thunk__2036 [input__2006 true-cont__2007 false-cont__2008] (if (seq? input__2006) (if (or (instance? clojure.lang.Seqable input__2006) (nil? input__2006)) (clojure.core/let [left__2031 (clojure.core/seq input__2006)] (if (clojure.core/not= nil left__2031) (clojure.core/let [left__2032 (clojure.core/first left__2031)] (if (clojure.core/= (quote leave) left__2032) (clojure.core/let [left__2033 (clojure.core/next left__2031)] (if (clojure.core/not= nil left__2033) (clojure.core/let [left__2034 (clojure.core/first left__2033)] (clojure.core/let [form left__2034] (clojure.core/let [left__2035 (clojure.core/next left__2033)] (if (clojure.core/= nil left__2035) (clojure.core/let [output__2009 (->Leave form)] (.invoke true-cont__2007 output__2009 nil)) (thunk__2030 input__2006 true-cont__2007 false-cont__2008))))) (thunk__2030 input__2006 true-cont__2007 false-cont__2008))) (thunk__2030 input__2006 true-cont__2007 false-cont__2008))) (thunk__2030 input__2006 true-cont__2007 false-cont__2008))) (thunk__2030 input__2006 true-cont__2007 false-cont__2008)) (thunk__2030 input__2006 true-cont__2007 false-cont__2008))) (thunk__2042 [input__2006 true-cont__2007 false-cont__2008] (if (seq? input__2006) (if (or (instance? clojure.lang.Seqable input__2006) (nil? input__2006)) (clojure.core/let [left__2037 (clojure.core/seq input__2006)] (if (clojure.core/not= nil left__2037) (clojure.core/let [left__2038 (clojure.core/first left__2037)] (if (clojure.core/= (quote guard) left__2038) (clojure.core/let [left__2039 (clojure.core/next left__2037)] (if (clojure.core/not= nil left__2039) (clojure.core/let [left__2040 (clojure.core/first left__2039)] (clojure.core/let [form left__2040] (clojure.core/let [left__2041 (clojure.core/next left__2039)] (if (clojure.core/= nil left__2041) (clojure.core/let [output__2009 (->Guard form)] (.invoke true-cont__2007 output__2009 nil)) (thunk__2036 input__2006 true-cont__2007 false-cont__2008))))) (thunk__2036 input__2006 true-cont__2007 false-cont__2008))) (thunk__2036 input__2006 true-cont__2007 false-cont__2008))) (thunk__2036 input__2006 true-cont__2007 false-cont__2008))) (thunk__2036 input__2006 true-cont__2007 false-cont__2008)) (thunk__2036 input__2006 true-cont__2007 false-cont__2008))) (thunk__2048 [input__2006 true-cont__2007 false-cont__2008] (if (seq? input__2006) (if (or (instance? clojure.lang.Seqable input__2006) (nil? input__2006)) (clojure.core/let [left__2043 (clojure.core/seq input__2006)] (if (clojure.core/not= nil left__2043) (clojure.core/let [left__2044 (clojure.core/first left__2043)] (if (clojure.core/= (quote quote) left__2044) (clojure.core/let [left__2045 (clojure.core/next left__2043)] (if (clojure.core/not= nil left__2045) (clojure.core/let [left__2046 (clojure.core/first left__2045)] (clojure.core/let [quoted left__2046] (clojure.core/let [left__2047 (clojure.core/next left__2045)] (if (clojure.core/= nil left__2047) (clojure.core/let [output__2009 (literal-ast (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list quoted))))] (.invoke true-cont__2007 output__2009 nil)) (thunk__2042 input__2006 true-cont__2007 false-cont__2008))))) (thunk__2042 input__2006 true-cont__2007 false-cont__2008))) (thunk__2042 input__2006 true-cont__2007 false-cont__2008))) (thunk__2042 input__2006 true-cont__2007 false-cont__2008))) (thunk__2042 input__2006 true-cont__2007 false-cont__2008)) (thunk__2042 input__2006 true-cont__2007 false-cont__2008))) (thunk__2052 [input__2006 true-cont__2007 false-cont__2008] (if (vector? input__2006) (if (or (instance? clojure.lang.Seqable input__2006) (nil? input__2006)) (clojure.core/let [left__2049 (clojure.core/seq input__2006)] ((.match-fn (zero-or-more seq-pattern)) left__2049 (clojure.core/fn [output__2050 rest__2051] (clojure.core/let [seq-patterns output__2050] (if (clojure.core/= nil rest__2051) (clojure.core/let [output__2009 (seqable-ast seq-patterns)] (.invoke true-cont__2007 output__2009 nil)) (thunk__2048 input__2006 true-cont__2007 false-cont__2008)))) (clojure.core/fn [] (thunk__2048 input__2006 true-cont__2007 false-cont__2008)))) (thunk__2048 input__2006 true-cont__2007 false-cont__2008)) (thunk__2048 input__2006 true-cont__2007 false-cont__2008))) (thunk__2053 [input__2006 true-cont__2007 false-cont__2008] (if (class-name? input__2006) (clojure.core/let [class-name input__2006] (clojure.core/let [output__2009 (class-ast class-name)] (.invoke true-cont__2007 output__2009 nil))) (thunk__2052 input__2006 true-cont__2007 false-cont__2008))) (thunk__2054 [input__2006 true-cont__2007 false-cont__2008] (if (primitive? input__2006) (clojure.core/let [literal input__2006] (clojure.core/let [output__2009 (literal-ast literal)] (.invoke true-cont__2007 output__2009 nil))) (thunk__2053 input__2006 true-cont__2007 false-cont__2008))) (thunk__2055 [input__2006 true-cont__2007 false-cont__2008] (if (binding? input__2006) (clojure.core/let [binding input__2006] (clojure.core/let [output__2009 (->Bind (binding-name binding))] (.invoke true-cont__2007 output__2009 nil))) (thunk__2054 input__2006 true-cont__2007 false-cont__2008)))] (strucjure/->Match (clojure.core/fn [input__2006 true-cont__2007 false-cont__2008] (if (clojure.core/= (quote _) input__2006) (clojure.core/let [output__2009 (->Leave nil)] (.invoke true-cont__2007 output__2009 nil)) (thunk__2055 input__2006 true-cont__2007 false-cont__2008)))))) (def seq-pattern '(clojure.core/letfn [(thunk__2062 [input__2056 true-cont__2057 false-cont__2058] ((.match-fn pattern) input__2056 (clojure.core/fn [output__2060 rest__2061] (clojure.core/let [pattern output__2060] (clojure.core/let [output__2059 (head-ast pattern)] (.invoke true-cont__2057 output__2059 rest__2061)))) (clojure.core/fn [] (.invoke false-cont__2058)))) (thunk__2068 [input__2056 true-cont__2057 false-cont__2058] (if (seq? input__2056) (if (or (instance? clojure.lang.Seqable input__2056) (nil? input__2056)) (clojure.core/let [left__2063 (clojure.core/seq input__2056)] (if (clojure.core/not= nil left__2063) (clojure.core/let [left__2064 (clojure.core/first left__2063)] (if (clojure.core/= (quote guard) left__2064) (clojure.core/let [left__2065 (clojure.core/next left__2063)] (if (clojure.core/not= nil left__2065) (clojure.core/let [left__2066 (clojure.core/first left__2065)] (clojure.core/let [form left__2066] (clojure.core/let [left__2067 (clojure.core/next left__2065)] (if (clojure.core/= nil left__2067) (clojure.core/let [output__2059 (->Guard form)] (.invoke true-cont__2057 output__2059 nil)) (thunk__2062 input__2056 true-cont__2057 false-cont__2058))))) (thunk__2062 input__2056 true-cont__2057 false-cont__2058))) (thunk__2062 input__2056 true-cont__2057 false-cont__2058))) (thunk__2062 input__2056 true-cont__2057 false-cont__2058))) (thunk__2062 input__2056 true-cont__2057 false-cont__2058)) (thunk__2062 input__2056 true-cont__2057 false-cont__2058)))] (strucjure/->Match (clojure.core/fn [input__2056 true-cont__2057 false-cont__2058] (if (seq? input__2056) (if (or (instance? clojure.lang.Seqable input__2056) (nil? input__2056)) (clojure.core/let [left__2069 (clojure.core/seq input__2056)] (if (clojure.core/not= nil left__2069) (clojure.core/let [left__2070 (clojure.core/first left__2069)] (if (clojure.core/= (quote &) left__2070) (clojure.core/let [left__2071 (clojure.core/next left__2069)] (if (clojure.core/not= nil left__2071) (clojure.core/let [left__2072 (clojure.core/first left__2071)] ((.match-fn pattern) left__2072 (clojure.core/fn [output__2073 rest__2074] (clojure.core/let [pattern output__2073] (if (clojure.core/= nil rest__2074) (clojure.core/let [left__2075 (clojure.core/next left__2071)] (if (clojure.core/= nil left__2075) (clojure.core/let [output__2059 pattern] (.invoke true-cont__2057 output__2059 nil)) (thunk__2068 input__2056 true-cont__2057 false-cont__2058))) (thunk__2068 input__2056 true-cont__2057 false-cont__2058)))) (clojure.core/fn [] (thunk__2068 input__2056 true-cont__2057 false-cont__2058)))) (thunk__2068 input__2056 true-cont__2057 false-cont__2058))) (thunk__2068 input__2056 true-cont__2057 false-cont__2058))) (thunk__2068 input__2056 true-cont__2057 false-cont__2058))) (thunk__2068 input__2056 true-cont__2057 false-cont__2058)) (thunk__2068 input__2056 true-cont__2057 false-cont__2058))))))
